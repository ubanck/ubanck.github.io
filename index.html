<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>少年鲜衣怒马，仗剑天涯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="少年鲜衣怒马，仗剑天涯">
<meta property="og:url" content="http://ubanck.com/index.html">
<meta property="og:site_name" content="少年鲜衣怒马，仗剑天涯">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="少年鲜衣怒马，仗剑天涯">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="少年鲜衣怒马，仗剑天涯" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ubanck</a></h1>
		</hgroup>

		
		<p class="header-subtitle">只要心还透明，就能折射希望</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ubanck</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/avatar.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">ubanck</h1>
			</hgroup>
			
			<p class="header-subtitle">只要心还透明，就能折射希望</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-做该做的事儿" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/18/做该做的事儿/" class="article-date">
  	<time datetime="2016-06-18T09:22:10.000Z" itemprop="datePublished">2016-06-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/18/做该做的事儿/">做该做的事儿</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>人心是渐渐变凉的，树叶是慢慢变黄的，故事缓缓写到结尾！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-转变画风" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/转变画风/" class="article-date">
  	<time datetime="2016-06-13T00:01:03.594Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/转变画风/">转变画风(方式方法)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>下午的时候，新的电脑到位了，上一台笔记本终于算是功德圆满，退居幕后了！一直想写点东西，只是一直没时间，或者说一直没功夫来做这件事，就一直拖着拖着，总给自己找理由，现在，终于有时间静下来写点东西给自己！</p>
<p>###态度：<br>对自己来说，无聊是最不应该出现的一种情绪，青春以各种方式过都好，只是以浪费不行！之前的生活方式过够了，是该换种画风了！</p>
<p>###技术：<br>准备多学点东西，准备选择一个方向深耕细作一下，梳理一下技能树，给自己找个确定的方向，各种学东西，技术才是立身之本！</p>
<p>###社交：<br>之前习惯了前呼后拥，组队一起玩的日子，以为那是人缘好，有意思，现在看来，其实都是无效社交，大家本来就不熟，有什么好玩的。遇事沉不住气，说的多做点少，总想去炫耀着什么，然而没有什么实际意义，渐渐发现孤单点更好一个人做很多事，简单直接！何苦要去迎合，惧怕孤独的本质是什么，是无所事事！少年，不要这样，该长大了，学会一个人嗨，不要畏惧一个人，他人的眼光有什么意义。<br>no matter social or not,do something what make you happy ,don’t waste time for something you dislike</p>
<p>###计划：<br>渐渐学会给自己订立计划，并且努力去做到，而不是订了之后就去忽视，想做一件事的时候，评估成本，预测收益，确定要做，即给自己设定计划，并且按照计划去做，目力所及，即是方向！</p>
<p>###学习：<br>多看书，对好书精读，对知识掌握，浅尝辄止这种事儿，浪费时间啊！看一本书，如果认可价值，就老老实实读完，别当打酱油一样</p>
<p>###健身：<br>本来以为已经差不多了的，妈蛋细细一看，感觉明显还是肥啊，而且从一月底之后，就没怎么进行锻炼了，这不行啊，少年，现在还是肥啊，脸大肚子大的！臃肿的身躯，撑不起我伟岸的灵魂了！找个时间，开始准备去健身房混了，今年年底，一定要练出腹肌，少年，奔跑吧！</p>
<p>###吉他：<br>这种装逼神器，我觉得我必须要掌握啊，去年说的要学会弹天空之城，可不能半途而废，加油学啊，少年！<br>做每件事儿都要找准方向，这可能比努力更重要了！<br>不要照小镜子，因为照镜子就会扣脸</p>
<p>###每日必备：<br>一小时学吉他<br>四十分钟insanity<br>看书写博客，从新开始学，详细点计划稍后制定<br>制定攒钱计划，每月需要攒钱二分之一到三分之二的样子，控制住花钱的欲望，买必须的！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-延迟渲染技术(Deferred Shading)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/延迟渲染技术(Deferred Shading)/" class="article-date">
  	<time datetime="2016-06-13T00:01:03.590Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/延迟渲染技术(Deferred Shading)/">延迟渲染技术(Deferred Shading)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们一直使用的光照方式叫做正向渲染(Forward Rendering)或者正向着色法(Forward Shading),这是渲染物体一种很直接的方式，根据物体材质，计算所有光源来照亮该物体，之后再去渲染下一个物体，非常简单，很容易理解，也很容易实现!<br>但是实际上计算次数过多，因为片段着色器昂贵的计算开销！如果有M个物体，N个光源，那么一个物体需要计算N次，M个物体就需要M<em>N次片段计算，计算成本太高，而更扯淡的是，因为多数相同位置的片段会被覆盖，所有，大多数的计算是毫无意义的！<br>延迟渲染就为了解决上述问题而诞生的，它用另外一种思路改变了渲染物体的方式，让我们可以对大量光源进行渲染，而保持着相对不错的帧率！顾名思义，延迟渲染的核心在于延迟，将大部分计算量非常大的渲染延迟到后期进行处理！包含两个处理阶段（Pass）:第一个几何处理阶段(Geometry Pass),先渲染场景一次，获取对象的几何信息，并存储在一系列叫做G缓冲(G-Buffer)。想想位置向量(Position Vector)、颜色向量(Color Vector)、法向量(Normal Vector)和/或镜面值(Specular Value)场景中这些储存在G缓冲中的几何信息将会在之后用来做(更复杂的)光照计算。<br>第二个光照处理阶段(Lighting Pass)，使用G-Buffer中的纹理数据，在光照处理阶段中，渲染一个屏幕大小的方形，使用G-Buffer中的几何数据对每个片段计算场景的光照，这样可以把M</em>N变成了M+N，当两者数量够大的时候，这种提升是成数量级的！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-渲染管线坐标变换" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/渲染管线坐标变换/" class="article-date">
  	<time datetime="2016-06-13T00:01:03.585Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/渲染管线坐标变换/">渲染管线坐标变换</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>2D展示<br>如果在2D上面，很简单，完全可以看作是一张图贴在屏幕上就OK。在3D上面，就复杂了一点，首先，我们的屏幕上2D的，不像现实世界，是三维空间！那么怎么在屏幕上画东西才能看上去有3D效果呢，你可以试试在纸上画一个立方体，学过数学都会画，你第一眼看上去就会觉得这是3D的，而不是一个简单的矩形！　　<br>2.模型坐标系<br>模型坐标系：在计算机的3D世界里，也是通过这样一种东西来实现了3D效果。如果在计算机屏幕上面绘制3D模型，那么我们首先在3D软件上制作出这个模型，这个模型会有一个原点，来建一个坐标系，无论是左手还是右手都差不多，这个坐标系，我们就叫做模型坐标系，那么这个模型的每个部位都相对于原点有一个坐标。</li>
<li>世界坐标系<br>世界坐标系：既然每个模型都有一个坐标系，就相当于你自己举着手，你的手在脸的正前方，那么相对于旁边的人，你的手在哪儿。那么就会有了一个概念叫世界坐标系，在世界坐标系中，每个模型的坐标都是相对于世界坐标系原点的，那么除非重叠，否则是不可能出现坐标一样的情况。就相当于你站的位置，不会再有人站了一样。而我们的光照计算也会是在世界坐标系中进行。</li>
<li>摄影坐标系<br>摄影坐标系：每个人都是在以自己的眼睛来看这个世界，比如你转动你的眼睛，看到的事物就会不一样。同样，在计算机的世界里，每次只能从唯一的视角出发来渲染物体，3D游戏都会提供摄像机漫游的功能，屏幕显示的内容会随着摄像机的变化而变化，这是因为GPU将物体的顶点坐标从世界坐标系转到了摄像机坐标系。所谓的摄像机坐标系，是以摄像机为原点，由视线方向，视角和远近平面，组成的一个梯形体的三维空间，叫做viewing frustum(视锥体）<br>既然可以看见的区域已经确定，那么GPU就得做一下筛检，就像你面朝大海，即便春暖花开，你也只能看到你朝着的那面，你背后的风景你是看不到的，但那又客观存在着。这个时候，GPU就得做一下裁剪，在这个区域内的东西才会渲染，不在这个区域内的，那就只能被抛弃了，这一步叫做裁剪（clip）,怎么判断物体在不在这个区域的过程，叫做裁剪算法。<br>至于怎么裁剪的，过程算法比较复杂，请自行参阅资料（这个过程也可以在应用程序中做）。裁剪过后，你这些东西都还是在3D空间里面的概念，而始终得显示在二维的屏幕上面，那么就得有个过程叫做屏幕映射，也就是说将3D的东西在2D的平面上显示出来就如同将这个立方体画在纸上，而你一看到一张纸上画的图，还是看出3D效果来。<br>之后的步骤，叫做图元装配，根据顶点的位置和索引关系，组成线和面，然后将超出屏幕外的三角形进行裁剪，就像一个三角形有一个顶点在屏幕外，剪掉之后，这三角形就会变成四边形了。接下来的过程，叫做光栅化，所谓光栅化，就是给显示器的像素点赋值，屏幕是由一个一个的像素点构成，给每个点赋值上相应的颜色，连起来就是一整个屏幕了，结果之前的过程，我们可以得到每个点的屏幕坐标值，也知道我们要绘制成啥样（点，线，面）<br>之后，我们就需要知道每个顶点的颜色了，这个颜色也在顶点信息之中，其中会牵涉到一种情况叫做混色，是根据当前的颜色跟正在计算的颜色的透明值，混合为一种颜色进行输出，也就是我们常说的Alpha值，一般叫做alpha混合技术，每个像素都关联一个RGB颜色值和一个A值，Alpha值用来描述物体的透明度.<br>计算公式为newColor=curColora+(1-a)nextColor 。混合之后，颜色被写入帧缓存中。那么如果同样一个位置的，有两个顶点，如果有两种颜色，而且都不透明，那么，到底是绘制那一种颜色呢？这里就有一个概念，叫做Z Buffer一般叫Z缓冲区，或者叫深度缓冲区，用来确定这个遮挡关系，这个值在（0,1）值越小，离近裁屏幕就更近，想象一下，在现实生活中，两块木板竖着叠在你面前，你当然只能看到近的那块。那么，GPU通过比较来判断顶点之间的遮挡关系，这个值其实也只是一个相对的大小，完全就是用来比较才有用的。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-漫反射光照" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/漫反射光照/" class="article-date">
  	<time datetime="2016-06-13T00:01:03.581Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/漫反射光照/">漫反射光照</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在游戏开发过程中，光照应该是必不可少部分，当然，这是指大多数的稍微大型一些的3D游戏会需要，给模型或者山山水水加上光照，会看上去更加的真实，获得更好的体验。一个本身不发光物体显示什么颜色，在于本身反射什么颜色，比如一块石头，在太阳光的照射之后，你看到是红色的，而太阳光是白色的，白色是因为RGB组合而成，这快石头吸收了绿色和蓝色，反射了红色，那么你看到这块石头就会是红色的！<br>那么谈到反射，就分为了漫反射（diffuse）和镜面反射（specular），先说漫反射</p>
<p>因为表面凹凸不平，所有法线的方向也就不一致，那么反射的光线也就不一致，何为法线，所谓法线，就是垂直与表面的那条线（看到一个哥们儿说因为法线一定是垂直的线，像个公正不阿的法官，所以叫法线），入射光线到表面，令入射光线与反射光线的夹角相等，得到反射光线，而我们在计算中是试用dot(N,L)来得到一个值，N代表法线向量，L代表入射光线的向量表示，先对这两个向量进行归一化处理（使用normalize函数）所谓的归一化处理，即是让这个向量的模等于1（其实就是让向量除以他的模，这块可以参考3D图形学基础里面提到的向量部分），而dot函数的公式为向量点乘，即NL=|N||L|cosΘ 由于之前对N与L进行了归一化处理，那么N<em>L=cosΘ，回顾一下三角函数，也就是说，入射光线与法线夹角在（0,90）之间，角度越大，那么值就越小。<br>　　下面给出漫反射的公式：diffuse = Kd lightColor max(N·L,0)。<br>　　首先kd为光强，也就是光照的强度，准确的说是材质对光的反射系数，在0到1 之间，根据名称可以自己想象一下。其次lightColor，这玩意儿是指光的颜色，它里面有rgb三个分量，用句牛逼的话说，世界上所有的颜色都可以用RGB来表示，通过在计算机中RGB三个不同的值可以匹配出无数种颜色，8bit的颜色通道可以表示出0-255，那么256的3次方，就可以组合得到16777216种颜色，当然，人的眼睛貌似感觉不到那么多颜色，扯远了，回到刚刚那个话题，光的颜色有了，在乘以max(N</em>L,0)，为什么要这样做？因为如果夹角大于90度，那么就会出现负数，负数是没有意义的（至于为什么会出现大于90度的情况，请发挥空间想象能力（脑补）），这样就得到了漫反射的颜色值了！！！<br>（就是简单是梳理一下思路！漫反射的代码，待会儿上传一下，作为总结）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-技能树梳理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/技能树梳理/" class="article-date">
  	<time datetime="2016-06-13T00:01:03.577Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/技能树梳理/">技能树梳理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>规划整个技术文章的走向，即分析整个技术体系，以博客文章的方式来归纳总结<br>图形学：整个绘制管线，GPU渲染知识，各种常用与不常用的Shader编写及原理</p>
<p>U3D：归纳总结工作中所遇到的各种坑，梳理代码脉络，一方面是注意代码架构，一方面是注意自己的写法，着重关注Shader,战斗系统，内存管理，自动更新，DrawCall优化，内存优化！<br>业余：关注别的相关技术，目前关注一下WebGL的相关点，看能不能对其贡献相关代码</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-高级光照模型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/高级光照模型/" class="article-date">
  	<time datetime="2016-06-13T00:01:03.572Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/高级光照模型/">高级光照模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>材质和光的交互方式是多种多样的，例如，我们可以在光盘上看到如扇面般的光带分布，在光滑的圆柱形炊具上可以看到光的条纹。为了衡量材质的光学特 征和物体表面微平面特征，BRDF（Bidirectional Reflectance Distribution Function） 模型应运而生。 以BRDF模型为代表的一些新的光照模型，它们的共同特点 是，扩展了材质和光的交互方式，充分考虑材质微平面对光的影响。</p>
<p>BRDF表示双向反射分布函数（Bidirectional Reflectance Distribution Function），用来描述光线如何在物体表面进行反射</p>
<p>经典光照模型(illumination model)<br>光照模型，也叫明暗模型，用来计算物体某点处的光强，即在游戏或者3D软件中看到类似于光线反射强弱的部分！<br>从算法理论基础上讲，分成两种，一种是基于物理理论（使用物理方式进行计算如BRDF，效果真实，计算复杂，实现困难，部分数据需要仪器测量），另一种是基于经验模型（使用特定的公式来计算，使其与某种特定表面类型相匹配，简洁，效果偏于理想而不真实）</p>
<p>从使用角度来讲，光照模型分为局部光照模型和全局光照模型，局部光照模型是说，讲光的种类进行分解，在计算的时候，只去考虑其中一种；而全局光照模型，则是考虑到所有的光照种类。一个比较类似的例子是物理力学，牛顿力学初<br>是考虑理想状态下的运动方式，无摩擦力；然后慢慢的会在力的条件中考虑到摩<br>擦力因素；接着会学习弹性系数。总之是将一个原本复杂的过程分解为各种子过 程，然后渐进叠加。<br>在现实世界，光照射到物体表面，一部分被吸收（光能转化为热量），另一部分被反射，对于透明的物体，如冰块玻璃，会穿透物体表面，产生透射光，反射光与投射光产生视觉效果，通过反射和透射产生的光波（光的波粒二相性）决定了物品呈现的亮度和颜色，即反射强度决定亮度，含有的不同波光长的比例决定色彩。<br>光与物品的最基本交互方式就是反射，遵循反射定律！<br>光源：<br>环境光(Ambient Light):从物体表面所产生的反射光的统一照明，称为环境光或者背景光。理想情况下，没有空间或方向性，在所有方向和物体表面投射的环境光强度是统一的恒定值。<br>由于环境光给予物体各个点的光照强度相同，且没有方向之分，所以在只有<br>环境光的情况下，同一物体各点的明暗程度均一样，因此，只有环境光是不能产 生具有真实感的图形效果。<br>粗糙的物体表面向各个方向等强度地反射光，这种等同地向各个方向散射的 现象称为光的漫反射（diffuse reflection）。产生光的漫反射现象的物体表面称为 理想漫反射体，也称为朗伯（Lambert）反射体。<br>Lambert 模型较好地表现了粗糙表面上的光照现象，如石灰粉刷的墙壁、纸张等，但在用于诸如金属材质制成的物体时，则会显得呆板，表现不出光泽，主要原因是该模型没有考虑这些表面的镜面反射效果。一个光滑物体被光照射时，可以在某个方向上看到很强的反射光，这是因为在接近镜面反射角的一个区域内，反射了入射光的全部或绝大部分光强，该现象称为镜面反射。故此，Phong Bui Tuong 提出一个计算镜面反射光强的经验模型，称为 phong模型，认为镜面反射的光强与反射光线和视线的夹角相关</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Unity DrawCall优化记录" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/Unity DrawCall优化记录/" class="article-date">
  	<time datetime="2016-06-13T00:01:03.565Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/Unity DrawCall优化记录/">Unity DrawCall优化记录</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前负责了一部分Unity DrawCall的优化工作，现将相关记录如下<br>DrawCall是指CPU准备各种数据送达到GPU进行渲染的过程，属于重度操作，DrawCall影响最大的是帧率！直接体验就是卡！<br>目前优化了大地图里面UI的DrawCall问题，由之前的数量相关，合并优化之后，DrawCall降为2个<br>同样，主界面的UI也是，原来杂乱无章的摆放，导致DrawCall数量太多，有意识的重新组织顺序，根据Unity 的渲染顺序，则可以保证在动态batch中，合并大量的DrawCall！目前主界面UI的DrawCall又30个下降到5个左右（包括一部分3D Mesh,所以无法直接降为2）<br>此外，主界面有3D的模型作为背景，经检查，此部分DrawCall多达150个，令人发指啊，简直不能忍！目前展开优化的方式有三种：1.直接将背景隐藏（影响原本效果），2.将所有的陨石背景合并（目测影响效果）3.由指定方式渲染（即修改顺序，修改参数，对效果的影响几乎可以忽略）<br>为了达到最低的DrawCall，又不过多损失效果，采取符合规则来进行Batch的策略。目前根据Unity渲染顺序，及官方文档提供的说明，整理出优化方案如下：<br>1.排列顺序：UGUI的渲染顺序为从上到下，即你所看到的Hierarchy上面的顺序，在使用同一图集的情况下，连续多次对图片（相同或者不同）的渲染，只占用一个DrawCall，对文字的渲染同理，只要不交叉渲染图片和文字，理论上讲，这样可以把整个UI的Draw降低到2！<br>2.渲染文字：最好使用同一字体，在使用多种字体的时候，最后如1所提示，按顺序来！<br>3.图集的是用，将图片打包成图集的时候，有可能因为图片的格式问题，或者通道之类的问题，导致明明设置在同一图集名称，却打包成了统一图集的两组。所以，尽量使用统一格式！<br>4.同材质模型：渲染许多使用相同材质的模型，有个最容易忽略的地方，Scale如果不一样不能Batch，此外还有对顶点数目，shader的pass数量等有限制，不符合会break batching！<br>5.脚本对材质的访问：访问某个使用共享材质的mesh时，考虑使用render.sharedMaterial而不是render.material，后者会在内存中生成一份拷贝！<br>6.静态batch：在制作场景的时候，如果能保证mesh本身不发生任何变化，可以使用，效果不错，就限制大！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-shader language概述" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/shader language概述/" class="article-date">
  	<time datetime="2016-06-13T00:01:03.561Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/shader language概述/">shader language概述</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从硬件上讲，GPU内部有顶点着色器与片段着色器，从渲染管线来看，顶点着色器控制这顶点的坐标转换过程，片段着色器控制像素的颜色计算过程。顶点着色器将顶点转换完成，输入到片段着色器进行处理（片段着色器具有检索纹理信息的能力，对于GPU而言，纹理等价于数组，暂时顶点着色器还不具备）<br>　　顶点着色程序从寄存器中提取出图元信息，所谓的图元信息包括（顶点的位置，法向量，纹理坐标），这些信息是来自于应用程序端，如果有DX或者OpenGL编程经验的，应该对这个很了解。获得图元信息之后，顶点着色程序完成 顶点坐标空间转换、法向量空间转换，光照计算等操作过程。</p>
<p>　　上一篇文章提到顶点坐标一开始是在模型空间坐标系，然后到世界空间坐标系等等，而光照计算也在这个阶段完成，因为光照会牵涉到法向量，所以需要在世界空间坐标系中做处理。完成这些之后，数据传输给了片段着色器，这个时候的数据里面包含的是纹理坐标和光照信息等等，片段着色器拿到之后，进行每个片段的颜色计算，最后将处理后的数据送到光栅化操作模块，所谓的光栅化操作模块执行的操作就是将颜色赋值到对应的像素点，这个操作就叫做光栅化！<br>　　那么我们可以这样说，顶点着色程序主要进行几何方面的计算，而片段着是器主要是针对最终的颜色进行计算。笔记：片段是啥？顶点好理解，像素也好理解，那啥是片段呢？片段其实就是光栅化之后的数据集合，这些数据还没经过深度值比较，而像素是经过比较了的。<br>　　讲完了GPU的执行过程与基本原理，那就该到正题了，就得说到我们的shader编程了，只要一说到编程，就会提到语言，shader语言现在说起来应该是三种 DX的HLSL(high level shading language),OpenGL的GLSL(OpenGL shading language)还有nvidia的CG(C for Graphics)！！！HLSL和GLSL的本质上是差不多的，而CG语言运行在DX和OpenGL的上层，能被这两者很好的支持，并且因为我本身目前使用Unity3D开发游戏，还有就是CG写起来很方便，所以shader的讲解就会围绕CG来讲！CG的语法我就不详细讲解了，这玩意儿可以参考官方文档，而且你看名字就能感觉到，肯定跟C差不多。相关的函数：<a href="http://http.developer.nvidia.com/Cg/index.html。" target="_blank" rel="external">http://http.developer.nvidia.com/Cg/index.html。</a><br>　　到这里基础全部铺垫完毕，其中那些变换的细节需要参与的数学公式推导暂时不表，读者只需要知道用公式那么算就好，推导过程可以参见《3D数学基础：图形与游戏开发》一书，里面对这方面进行了比较详细的讲解。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Lua and Unilua" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/Lua and Unilua/" class="article-date">
  	<time datetime="2016-06-13T00:01:03.557Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/Lua and Unilua/">Lua and Unilua</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###LUA学习记录：<br>C API是一个C代码与Lua进行交互的函数集。他有以下部分组成：读写Lua全局变量的函数，调用Lua函数的函数，运行Lua代码片断的函数，注册C函数然后可以在Lua中被调用的函数，等等。<br>在C和Lua之间通信关键内容在于一个虚拟的栈。几乎所有的API调用都是对栈上的值进行操作，所有C与Lua之间的数据交换也都通过这个栈来完成。另外，你也可以使用栈来保存临时变量。<br>Lua库没有定义任何全局变量。它所有的状态保存在动态结构lua_State中，而且指向这个结构的指针作为所有Lua函数的一个参数。</p>
<p>###运行步骤：<br>创建一个state并将标准库载入之后，就可以着手解释用户的输入了。对于用户输入的每一行，C程序首先调用luaL_loadbuffer编译这些Lua代码。如果没有错误，这个调用返回零并把编译之后的chunk压入栈。（记住，我们将在下一节中讨论魔法般的栈）之后，C程序调用lua_pcall，它将会把chunk从栈中弹出并在保护模式下运行它。和luaL_laodbuffer一样，lua_pcall在没有错误的情况下返回零。在有错误的情况下，这两个函数都将一条错误消息压入栈；我们可以用lua_tostring来得到这条信息、输出它，用lua_pop将它从栈中删除。</p>
<p>###堆栈：关于栈的操作请参见Programing in Lua一书中的186页的一个函数<br>压入元素，API有一系列压栈的函数，他将每种可以用C来描述的Lua类型压栈（pushnil,pushnumber,pushboolean,pushstring）等等，第一参数都是luaState!<br>使用checkStack来检测栈是否有足够的空间！<br>有检测元素类型的函数，比如 isnumber之类的！</p>
<p>###查询元素，tonumber,tostring之类的<br>堆栈的操作，gettop返回堆栈元素个数，也是栈顶元素的索引！settop设置栈顶（堆栈中元素个数）为一个指定的值！如果开始的栈顶高于指定的栈顶，顶部的值将会被丢弃！settop(L,0)清空堆栈！<br>使用负数会设置堆栈顶到指定的索引！<br>pushvalue压入堆栈上指定索引的一个拷贝到栈顶！insert移动栈顶的元素到指定索引的位置，并将这个索引位置上面的元素全部上移至栈顶被移动后留下的空隔！<br>replace从栈顶弹出元素将其设置到指定索引位置，没有任何移动操作<br>LUA中使用更多的使用对栈的操作来实现数据的交互！提供了一些对栈操作的API标准，在UniLua中，依照标准实现了这些函数，名字都只是小改动了一些，毕竟C#跟C语法规则还是不同！在对堆栈的操作中，是用索引来进行定位的，正数索引自底向上取值，负数索引自顶向下取值（以正负1开始）！在其中settop函数中使用了索引0用来清空堆栈</p>
<p>###扩展你的程序<br>做为配置语言是LUA的一个重要内容！<br>打开包并加载函数库，加载文件中的信息块 （参见188页 ）<br>引入table的概念<br>如 ；在Lua文件中进行这样的定义：BLUE={r=0,g=0,b=1} background=BLUE 在C程序里面引用getglobal(L,background); red=getfield(“r”) green=getfield(“g”)……<br>getfield函数在标准的LUA库里面没有提供，需要自己实现，在LuaAPI中提供了gettable函数，他接受table在栈中的位置为参数，将对应key值出栈，返回与key对应的value！<br>也就是说，可以使用这个方式，将对栈的操作进行封装，封装一个getfield函数来方便我们对table中值的取的。</p>
<p>###The Registry<br>registry 一直位于一个由LUA_REGISTRYINDEX定义的值所对应的假索引(pseudo-index)的位置。一个假索引除了他对应的值不在栈中之外，其他都类似于栈中的索引。<br>registry就是普通的Lua表，因此，你可以使用任何非nil的Lua值来访问她的元素。然而，由于所有的C库共享相同的registry ，你必须注意使用什么样的值作为key，否则会导致命名冲突。<br>registry实现了全局的值，upvalue机制实现了与C static等价的东西</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 ubanck
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>